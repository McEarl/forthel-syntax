# FTL parsing

This chapter describes a specification of a parser for lexed FTL documents. This
means a parser for the grammar described in this chapter is intended to accept a
list of lexemes generated by a parser for the grammar described in the previous
chapter and returns for instance an abstract syntax tree for such an FTL
document.

```nbnf
<ftl text> = { <forthel section> }
```

```nbnf
<forthel section> = <instruction>
                  | <declaration>
                  | <top-level section>
```


## Special strings

```nbnf
<label> = <label token> { <label token> }
```

```nbnf
<name> = "(" <label> ")"
```

_The following rule is adopted from [[2]](#references)._

```nbnf
<reference> = "(" 'by' <label> { "," <label> } ")"
```

```nbnf
<variables> = <variable> { "," <variable> }
```

```nbnf
<variable> = <variable token> { "\'" }
```

```nbnf
<var> = <var token>
```

```nbnf
<qed> = ( 'qed' | 'end' | 'obvious' | 'trivial' ) [ <reference> ] "."
```


## Keywords

```nbnf
<assume> = 'assume'
         | 'presume'
         | 'suppose'
```

```nbnf
<iff> = 'iff'
      | 'if' 'and' 'only' 'if'
      | 'when' 'and' 'only' 'when'
```

```nbnf
<is> = 'is'
     | 'are'
     | 'be'
```

```nbnf
<does> = 'does'
       | 'do'
```

```nbnf
<has> = 'has'
      | 'have'
```

```nbnf
<with> = 'with'
       | 'of'
       | 'having'
```

```nbnf
<let us> = 'let' 'us'
         | 'we' 'can'
```

```nbnf
<stand for> = 'stand' 'for'
            | 'denote'
```

```nbnf
<then> = 'then'
       | 'hence'
       | 'thus'
       | 'therefore'
       | 'consequently'
```

```nbnf
<article> = <indefinite article>
          | <definite article>
```

```nbnf
<indefinite article> = 'a'
                     | 'an'
```

```nbnf
<definite article> = 'the'
```


## Instructions

```nbnf
<instruction> = "[" <instr> "]"
```

```nbnf
<instr> = <command instruction>
        | <limit instruction>
        | <flag instruction>
        | <argument instruction>
        | <synonym instruction>
        | <drop instruction>
```


### Command instructions

```nbnf
<command instr> = "exit"
                | "quit"
                | "thesis"
                | "context"
                | "filter"
                | "rules"
```


### Limit instructions

```nbnf
<limit instruction> = <limit instr> <limit>
```

```nbnf
<limit instr> = "timelimit"
              | "memorylimit"
              | "depthlimit"
              | "checktime"
              | "checkdepth"
```

```nbnf
<limit> = <numeric token>
```


### Flag instructions

```nbnf
<flag instruction> = <flag instr> <bool>
```

```nbnf
<flag instr> = "prove"
             | "check"
             | "checkconsistency"
             | "symsign"
             | "info"
             | "thesis"
             | "filter"
             | "skipfail"
             | "flat"
             | "printgoal"
             | "printsection"
             | "printcheck"
             | "printunfold"
             | "printreason"
             | "printprover"
             | "printfulltask"
             | "dump"
             | "printsimp"
             | "printthesis"
             | "unfold"
             | "unfoldsf"
             | "unfoldlow"
             | "unfoldlowsf"
             | "translation"
             | "tex"
```

```nbnf
<bool> = "yes"
       | "no"
       | "on"
       | "off"
```


### Argument instructions

```nbnf
<argument instruction> = <argument instr> <argument>
```

```nbnf
<argument instr> = "read"
                 | "readtex"
                 | "library"
                 | "provers"
                 | "prover"
```

```nbnf
<argument> = <argument token> { <argument token> }
```


### Synonym instructions

```nbnf
<synonym instruction> = "synonym" <regular alphabetic token> { "/" [ "-" ] <regular alphabetic token> }
```


### Drop instructions

```nbnf
<drop instruction> = "/" ( <command instr> | <limit instr> | <flag instr> )
```


## Declarations

```nbnf
<declaration> = <variable declaration>
              | <notion declaration>
              | <function declaration>
              | <predicate declaration>
```

```nbnf
<variable declaration> = 'let' <variables> <stand for> [ <article> ] <class noun> "."
```

```nbnf
<notion declaration> = 'let' <notion pattern> <stand for> [ <article> ] <class noun> "."
```

```nbnf
<function declaration> = 'let' <function pattern> <stand for> <plain term> "."
```

```nbnf
<predicate declaration> = 'let' <predicate pattern> <stand for> <statement> "."
```


## Patterns

### Notion, function and predicate patterns

```nbnf
<notion pattern> = <indefinite article> <alphanumeric pattern>
```

The usage of `⟨indefinite article⟩` is necessary to tell a variable from a
notion pattern and hence a type declaration from a notion declaration.


```nbnf
<function pattern> = <definite article> <alphanumeric pattern>
                   | <pattern>
```

```nbnf
<predicate pattern> = <var> <is> <alphanumeric pattern>
                    | <var> <alphanumeric pattern>
                    | <pattern>
```


### General patterns

```nbnf
<alphabetic pattern> = <regular alphabetic token> { <regular alphabetic token> }
```

```nbnf
<alphanumeric pattern> = <regular alphanumeric token> { <regular alphanumeric token> }
```

```nbnf
<symbolic pattern> = <regular symbolic token> { <regular symbolic token> }
```

```nbnf
<pattern> = <regular token> { <regular token> }
```

Note that we ignore variables in the definition of (symbolic) patterns since on
a syntactic level they cannot be distinguished from other tokens.


## Top-level sections

```nbnf
<top-level section> = <axiom>
                    | <definition>
                    | <signature extension>
                    | <theorem> [ <proof> ]
```


### Axioms

_The following rule is adopted from [[2]](#references)._

```nbnf
<axiom> = <axiom header> { <assumption> } <axiom affirmation>
```

_The following rule is adopted from [[2]](#references)._

```nbnf
<axiom header> = 'axiom' [ <label> ] "."
```

```nbnf
<axiom affirmation> = [ <then> ] <statement> "."
```


### Definitions

_The rules in this paragraph are adopted from [[2]](#references)._

```nbnf
<definition> = <definition header> { <assumption> } <definition affirmation>
```

```nbnf
<definition header> = 'definition' [ <label> ] "."
```

```nbnf
<definition affirmation> = <definition statement> "."
```


### Signature extensions

_The rules in this paragraph are adopted from [[2]](#references)._

```nbnf
<signature extension> = <signature header> { <assumption> } <signature affirmation>
```

```nbnf
<signature header> = 'signature' [ <label> ] "."
```

```nbnf
<signature affirmation> = <signature statement> "."
```


### Theorems

_The following rule is adopted from [[2]](#references)._

```nbnf
<theorem> = <theorem header> { <assumption> } <theorem affirmation>
```

_The following rule is adopted from [[2]](#references)._

```nbnf
<theorem header> = ( 'theorem' | 'proposition' | 'lemma' | 'corollary' ) [ <label> ] "."
```

```nbnf
<theorem affirmation> = [ <then> ] <statement> [ <reference> ] "."
```


## Assumptions

```nbnf
<assumption> = [ <name> ] <assumption prefix> <statement> "."
```

_The following rule is adopted from [[2]](#references)._

```nbnf
<assumption prefix> = 'let'
                    | [ <let us> ] <assume> [ 'that' ]
```


## Definition and notion statements

### Definition statements

_The following rule is adopted from [[2]](#references)._

```nbnf
<definition statement> = <notion definition>
                       | <function definition>
                       | <predicate definition>
```

```nbnf
<notion definition> = <notion head> ( "=" | <is> [ 'equal' 'to' ] ) [ <article> ] <class noun>
```

```nbnf
<function definition> = <function head> ( "=" | <is> [ 'equal' 'to' ] ) [ <article> ] ( <class noun> | <plain term> )
```

```nbnf
<predicate definition> = <predicate head> ( <iff> | "<" "=" ">" ) <statement>
```


### Signature statements

_The following rule is adopted from [[2]](#references)._

```nbnf
<signature statement> = <notion signature>
                      | <function signature>
                      | <predicate signature>
```

```nbnf
<notion signature> = <notion head> <is> [ <article> ]  (<class noun> | 'notion' | 'constant' )
```

```nbnf
<function signature> = <function head> <is> [ <article> ] <class noun>
```

```nbnf
<predicate signature> = <predicate head> ( 'implies' | 'is' | "=" ">" ) <statement>
                      | <predicate head> 'is' [ <article> ] ( 'atom' | 'relation' )
```

Note that in contrast to the rules before, `⟨predicate signature⟩` requires an
`'is'` instead of an `⟨is⟩`.


### Notion, function and predicate heads

_The rules in this paragraph are adopted from [[2]](#references)._

```nbnf
<notion head> = <article> <primitive class noun>
              | <notion pattern>
```

```nbnf
<function head> = [ <definite article> ] <primitive definition noun>
                | <primitive infix operator>
                | <primitive prefix operator>
                | <primitive postfix operator>
                | <function pattern>
```

```nbnf
<predicate head> = <variable> <is> <primitive adjective>
                 | <variables> <is> <primitive adjective>
                 | <variable> <primitive verb>
                 | <variables> <primitive verb>
                 | <primitive relation>
                 | <predicate pattern>
```


## Proofs

```nbnf
<proof> = <proof head> { <proof step> } <qed>
        | 'indeed' <confirmation>
```

```nbnf
<proof head> = 'proof' [ 'by' <method> ] "."
```

```nbnf
<confirmation> = <affirmation> [ <proof> ]
               | <choose> [ <proof> ]
               | <low-level definition>
               | <assumption>
               | <low-level theorem>
```

Note that in contrast to `⟨proof step⟩` low-level definitions cannot be followed
by a proof.

_The following rule is adopted from [[2]](#references)._

```nbnf
<method> = 'contradiction'
         | 'case' 'analysis'
         | 'induction' [ 'on' <plain term> ]
```

```nbnf
<proof step> = <affirmation> [ <proof> ]
             | <choose> [ <proof> ]
             | <low-level definition> [ <proof> ]
             | <assumption>
             | <case>
             | <low-level theorem>
             | <equality chain>
             | <instruction>
```

```nbnf
<low-level theorem> = <low-level theorem head> ( <affirmation> | <equality chain> ) [ <proof head> ] { <proof step> } <qed>
```

```nbnf
<low-level theorem head> = <let us> ( 'show' | 'prove' | 'demonstrate' ) [ 'by' <method> ] 'that'
```

```nbnf
<choose> = [ <name> ] [ <then> ] [ <let us> ] ( 'take' | 'choose' | 'consider' ) [ <article> ] <notions> [ <reference> ] "."
```

```nbnf
<case> = [ <name> ] 'case' <statement> [ <reference> ] "." { <proof step> } <qed>
```

```nbnf
<affirmation> = [ <name> ] [ <then> ] <statement> [ <reference> ] "."
```

```nbnf
<equality chain> = [ <name> ] <symbolic term> "." "=" <symbolic term> [ <reference> ] { "." "=" <symbolic term> [ <reference> ] } "."
```


## Low-level definitions

```nbnf
<low-level definition> = [ <name> ] <class definition>
                       | [ <name> ] <function definition>
```


### Class definitions

```nbnf
<class definition> = 'define' <variable> '=' ( <class term> | <class-of term> ) "."
```

```nbnf
<class term> = <descriptive class term>
             | <enumerative class term>
```

```nbnf
<descriptive class term> = "{" <separation> ( "|" | ":" ) <statement> "}"
```

```nbnf
<enumerative class term> = "{" <term> { "," <term> } "}"
```

```nbnf
<class-of term> = ( 'class' | 'classes' | 'collection' | 'collections' ) [ <variable> ] 'of' [ 'all' ] <notion>
```

```nbnf
<separation> = <term>
             | <term> 'in' ( <term> | <class term> | <class-of term> )
```


### Function definitions

```nbnf
<function definition> = 'define' <variable> "(" <variable> [ "," <variable> ] ")" "=" <function body> 'for' ( <variable> | "(" <variable> "," <variable> ")" ) 'in' <term> "."
                      | 'define' <variable> "=" <lambda term> "."
```

```nbnf
<function body> = <case function>
                | <plain function term>
```

```nbnf
<case function> = 'case' <statement> "-" ">" <plain function term> [ "," <case function> ]
```

```nbnf
<plain function term> = <choice term>
                      | <function term>
```

```nbnf
<choice term> = <low-level-def choice> { "," <low-level-def choice> } 'in' <function term>
```

```nbnf
<function term> = <term>
                | <lambda term>
                | <class term>
                | <class-of term>
```

```nbnf
<low-level-def choice> = 'choose' [  <article> ] <notion>
                       | 'define' <variable> "=" ( <class term> | <class-of term> | <lambda term> )
```

```nbnf
<lambda term> = "\\" ( <variable> | "(" <variable> "," <variable> ")" ) 'in' <lambda domain> "." <lambda body>
```

```nbnf
<lambda domain> = <term>
                | <descriptive class term>
                | <enumerative class term>
```

```nbnf
<lambda body> = <function term> | <case function> | <choice term>
              | "(" ( <function term> | <case function> | <choice term> ) ")"
```


## Statements

```nbnf
<statement> = <headed statement>
            | <chained statement>
```

```nbnf
<headed statement> = <quantified statement>
                   | <if-then statement>
                   | <it-is-wrong statement>
```

```nbnf
<chained statement> = ( <and chain> | <or chain> | <neither-nor chain> ) [ <chain end> ]
```

```nbnf
<quantified statement> = <quantifier chain> <statement>
```

```nbnf
<if-then statement> = 'if' <statement> 'then' <statement>
```

```nbnf
<it-is-wrong statement> = 'it' 'is' 'wrong' 'that' <statement>
```

```nbnf
<and chain> = <atomic statement> { 'and' <atomic statement> }
```

```nbnf
<or chain> = <atomic statement> { 'or' <atomic statement> }
```

```nbnf
<neither-nor chain> = 'neither' <atomic statement> 'nor' <atomic statement> { 'nor' <atomic statement> }
```

```nbnf
<quantifier chain> = 'for' <quantified notion> { "," <quantified notion> }
```

```nbnf
<chain end> = 'and' <headed statement>
            | 'or' <headed statement>
            | <iff> <statement>
            | ( 'when' | 'where' ) <statement>
```


### Atomic statements

```nbnf
<atomic statement> = <simple statement>
                   | <there-is statement>
                   | [ 'we' 'have' ] ( <symbolic statement> | <constant statement> )
```

```nbnf
<simple statement> = <terms> <does-predicate> { 'and' <does-predicate> } [ <late quantifiers> ]
```

```nbnf
<there-is statement> = 'there' ( 'is' | 'exists' | 'exist' ) ( <no notion> | [ <article> ] <notions> )
```

```nbnf
<symbolic statement> = ( <symbolic formula> | <class equality> ) [ <late quantifiers> ]
```

```nbnf
<constant statement> = [ <article> ] ( 'thesis' | 'contrary' | 'contradiction' )
```

```nbnf
<late quantifiers> = 'for' <quantified notion> { ( "," | 'and' ) <quantified notion> }
```

```nbnf
<class equality> = <class term> "=" <class term>
                 | <class term> "=" <symbolic term>
                 | <symbolic term> "=" <class term>
```


### Symbolic formulas

```nbnf
<symbolic formula> = <biimplication>
```

```nbnf
<biimplication> = <implication> [ "<" "=" ">" <implication> ]
```

```nbnf
<implication> = <disjunction> [ "=" ">" <implication> ]
```

```nbnf
<disjunction> = <conjunction> [ "\\" "/" <disjunction> ]
```

```nbnf
<conjunction> = <non-binary formula> [ "/" "\\" <conjunction> ]
```

```nbnf
<non-binary formula> = <universal formula>
                     | <existential formula>
                     | <negation>
                     | <separated formula>
                     | <atomic formula>
```

```nbnf
<universal formula> = 'forall' <symbolic notion> <non-binary formula>
```

```nbnf
<existential statement> = 'exists' <symbolic notion> <non-binary formula>
```

```nbnf
<negation> = 'not' <non-binary formula>
```

```nbnf
<separated formula> = ":" <symbolic formula>
```

```nbnf
<atomic formula> = <symbolic relation>
                 | "(" <statement> ")"
```

```nbnf
<symbolic relation> = <symbolic chain>
                    | <primitive circumfix predicate>
```

```nbnf
<symbolic chain> = <left head>
                 | <term chain> <symbolic tail>
```

```nbnf
<left head> = <primitive left predicate> <term chain>
```

```nbnf
<symbolic tail> = <infix tail>
                | <right tail>
```

```nbnf
<infix tail> = <primitive infix predicate> <term chain>
```

```nbnf
<right tail> = <primitive right predicate>
```

```nbnf
<term chain> = <symbolic term> { "," <symbolic term> }
```


## Notions

```nbnf
<notions> = <notion> { ( "," | 'and' ) <notion> }
```

_The following rule is adopted from [[2]](#references)._

```nbnf
<notion> = <class noun>
         | <class relation>
```

```nbnf
<no notion> = 'no' <notion>
```

_The following rule is adopted from [[2]](#references)._

```nbnf
<quantified notion> = ( 'every' | 'all' | 'any' | 'each' ) <notion>
                    | 'some' <notion>
                    | 'no' <notion>
```

```nbnf
<symbolic notion> = <variables> [ <pattern> ]
```


### Relations

_The following rule is adopted from [[2]](#references)._

```nbnf
<class relation> = { <left attribute> } "(" <primitive class relation> ")" [ <right attribute> ]
                 | { <left attribute> } <primitive class relation> [ <right attribute> ]
```

```nbnf
<primitive class relation> = <symbolic pattern> <variables> { <symbolic pattern> <symbolic term> } [ <symbolic tokens> ]
                           | <variables> <symbolic pattern> { <symbolic term> <symbolic tokens> } [ <symbolic term> ]
```


### Nouns

_The following rule is adopted from [[2]](#references)._

```nbnf
<class noun> = { <left attribute> } <primitive class noun> [ <right attribute> ]
```

```nbnf
<primitive class noun> = <alphabetic pattern> [ <variables> [ <alphabetic pattern> ] ] { <term> <alphabetic pattern> } [ <term> ]
```

_The following rule is adopted from [[2]](#references)._

```nbnf
<possessed noun> = { <left attribute> } <primitive possessed noun> [ <right attribute> ]
```

```nbnf
<primitive possessed noun> = <alphabetic pattern> [ <variables> [ <alphabetic pattern> ] ] { <term> <alphabetic pattern> } [ <term> ]
```

```nbnf
<primitive definite noun> = <alphabetic pattern> { <term> <alphabetic pattern> } [ <term> ]
```

```nbnf
<primitive plain noun> = <alphabetic pattern> { <term> <alphabetic pattern> } [ <term> ]
```


### Attributes

_The rules defined in this paragraph are adopted from [[2]](#references)._

```nbnf
<left attribute> = <primitive simple adjective>
                 | <primitive simple m-adjective>
```

```nbnf
<right attribute> = <is-predicate> { 'and' <is-predicate> }
                  | 'that' <does-predicate> { 'and' <does-predicate> }
                  | 'such' 'that' <statement>
```


### Predicates

_The rules in this paragraph are adopted from [[2]](#references)._

```nbnf
<is-predicate> = [ 'not' ] <primitive adjective>
               | [ 'not' ] [ 'pairwise' ] <primitive m-adjective>
               | <with> <has-predicate>
```

```nbnf
<is-a-predicate> = [ 'not' ] <indefinite article> <class noun>
                 | [ 'not' ] <definite term>
```

```nbnf
<does-predicate> = [ <does> ] [ 'not' ] <primitive verb>
                 | [ <does> ] [ 'not' ] [ 'pairwise' ] <primitive m-verb>
                 | <has> <has-predicate>
                 | <is> <is-predicate> { 'and' <is-predicate> }
                 | <is> <is-a-predicate> { 'and' <is-a-predicate> }
```

```nbnf
<has-predicate> = [ <article> ] <possessed noun> { 'and' [ <article> ] <possessed noun> }
```


### Adjectives

```nbnf
<primitive adjective> = <alphabetic pattern> { <term> <alphabetic pattern> } [ <term> ]
```

```nbnf
<primitive m-adjective> = <alphabetic pattern> { <term> <alphabetic pattern> } [ <term> ]
```

```nbnf
<primitive simple adjective> = <alphabetic pattern>
```

```nbnf
<primitive simple m-adjective> = <alphabetic pattern>
```


### Verbs

```nbnf
<primitive verb> = <alphabetic pattern> { <term> <alphabetic pattern> } [ <term> ]
```

```nbnf
<primitive m-verb> = <alphabetic pattern> { <term> <alphabetic pattern> } [ <term> ]
```


## Terms

_The rules in this paragraph are adopted from [[2]](#references)._

```nbnf
<terms> = <term> { ( "," | 'and' ) <term> }
```

```nbnf
<term> = "(" <quantified notion> ")"
       | <quantified notion>
       | <definite term>
```

```nbnf
<definite term> = "(" [ <definite article> ] <primitive definite noun> ")"
                | [ <definite article> ] <primitive definite noun>
                | <symbolic term>
```

```nbnf
<symbolic term> = <primitive infix operator>
                | <tighter symbolic term>
```

```nbnf
<tighter symbolic term> = <primitive prefix operator>
                        | <tightest symbolic term>
```

```nbnf
<tightest symbolic term> = <primitive postfix operator>
                         | "(" <symbolic term> ")"
                         | <variable>
```


### Operators

```nbnf
<primitive infix operator> = <tighter symbolic term> <pattern> <symbolic term>
```

```nbnf
<primitive prefix operator> = <pattern> <tighter symbolic term>
```

```nbnf
<primitive postfix operator> = <symbolic pattern>  { <symbolic term> <pattern> }
                             | <tightest symbolic term> "(" <symbolic term> ")"
```


### Plain terms

_The following rule is adopted from [[2]](#references)._

```nbnf
<plain term> = "(" [ <definite article> ] <primitive plain noun> ")"
             | [ <definite article> ] <primitive plain noun>
             | <symbolic term>
```
